<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Tank Battle ‚Äì –î–≤–∞ –∏–≥—Ä–æ–∫–∞</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body { 
      margin: 0; padding: 0; overflow: hidden; background: #222; 
      color: #fff; font-family: sans-serif;
    }
    #gameCanvas { background: #333; }
    #message {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 28px; z-index: 50;
      padding: 20px;
      background: rgba(0,0,0,0.8);
      border-radius: 10px;
      display: none;
    }
    .fireBtn {
      position: absolute;
      width: 90px; height: 90px;
      background: rgba(255,0,0,0.3);
      border-radius: 50%;
      display: flex; justify-content: center; align-items: center;
      font-size: 24px; color: white;
      right: 20px; bottom: 20px;
      z-index: 20; user-select: none;
    }
    #stats {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      z-index: 20;
      font-size: 14px; line-height: 1.4;
    }
    #backBtn {
      position: absolute;
      top: 10px; right: 10px;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 5px;
      z-index: 20; cursor: pointer;
    }
  </style>
  <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º adapter.js –¥–ª—è WebRTC -->
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <!-- –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º alert –∏ console.error -->
  <script>
    window.alert = function() {
      console.log("alert –≤—ã–∑–≤–∞–Ω —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏:", arguments);
    };
    console.error = function() {
      window._peerJsError = window._peerJsError || [];
      window._peerJsError.push(arguments);
    };
  </script>
  <!-- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –æ—à–∏–±–æ–∫ -->
  <script>
    window.addEventListener('error', function (event) {
      event.stopImmediatePropagation();
      event.preventDefault();
      console.log("–û—à–∏–±–∫–∞ –ø–æ–¥–∞–≤–ª–µ–Ω–∞:", event.message, "–ò—Å—Ç–æ—á–Ω–∏–∫:", event.filename, "–°—Ç—Ä–æ–∫–∞:", event.lineno);
      return true;
    }, true);
    window.addEventListener('unhandledrejection', function(event) {
      event.preventDefault();
      console.log("Unhandled Promise Rejection –ø–æ–¥–∞–≤–ª–µ–Ω:", event.reason);
    });
  </script>
</head>
<body>
  <div id="gameCanvas"></div>
  <div id="message">–û–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–∞‚Ä¶</div>
  <div id="stats">
    <div>–ñ–∏–∑–Ω—å: <span id="score">100</span></div>
    <div>–ü–æ—Å–ª–µ–¥–Ω–∏–π –±–æ–Ω—É—Å: <span id="lastBonus">–Ω–µ—Ç</span></div>
    <div>–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:</div>
    <div id="playerStats"></div>
    <div>FPS: <span id="fpsDisplay"></span></div>
  </div>
  <div id="backBtn">–ù–∞–∑–∞–¥</div>
  <div id="fireBtn" class="fireBtn">üî•</div>

  <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ Konva –∏ PeerJS -->
  <script src="https://unpkg.com/konva@8.4.3/konva.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
  
  <script>
  /***********************
   * –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
   ***********************/
  const viewWidth = window.innerWidth,
        viewHeight = window.innerHeight,
        worldWidth = 2500,
        worldHeight = 2500;
  // –†–µ–Ω–¥–µ—Ä: 15 —Ü–∏–∫–ª–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É
  let desiredFPS = 20;
  let lastFrameTime = 0;
  // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–∏–º—É–ª—è—Ü–∏–∏ —É–≤–µ–ª–∏—á–µ–Ω –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è —Å–æ–±—ã—Ç–∏–π (–±—ã—Å—Ç—Ä–µ–µ, —á–µ–º —Ä–∞–Ω–µ–µ)
  const simStep = 0.1;

  const stage = new Konva.Stage({
    container: 'gameCanvas',
    width: viewWidth,
    height: viewHeight
  });
  const layer = new Konva.Layer();
  stage.add(layer);
  const worldGroup = new Konva.Group();
  layer.add(worldGroup);

  function resizeCanvas() {
    stage.width(window.innerWidth);
    stage.height(window.innerHeight);
  }
  window.addEventListener('resize', resizeCanvas);

  /***********************
   * –ö–ª–∞—Å—Å—ã –∏–≥—Ä—ã
   ***********************/
  class Tank {
    constructor(x, y, color, isPlayer = false) {
      this.x = x;
      this.y = y;
      this.color = color;
      this.rotate = 0;
      this.speed = 0;
      this.durability = 100;
      // –ë–∞–∑–æ–≤—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
      this.baseMaxSpeed = isPlayer ? 2 : 1.5;
      this.baseReloadTime = 7.5;
      this.baseBulletDamage = 1;
      this.baseBulletPenetration = 35;
      this.maxSpeed = this.baseMaxSpeed * (this.durability / 100);
      this.reloadTime = this.baseReloadTime * (100 / this.durability);
      this.bulletDamage = this.baseBulletDamage * (this.durability / 100);
      this.bulletPenetration = this.baseBulletPenetration * (this.durability / 100);
      this.reload = 0;
      this.size = 30;
      this.barrelLength = 20;
      this.body = new Konva.Rect({
        x: this.x + this.size/2,
        y: this.y + this.size/2,
        width: this.size, height: this.size,
        fill: this.color,
        offset: { x: this.size/2, y: this.size/2 }
      });
      worldGroup.add(this.body);
      this.barrel = new Konva.Rect({
        x: this.x + this.size/2,
        y: this.y + this.size/2,
        width: this.barrelLength, height: 6,
        fill: '#000',
        offset: { x: 0, y: 3 }
      });
      worldGroup.add(this.barrel);
      this.isPlayer = isPlayer;
      this.alive = true;
    }
    recalcStats() {
      let eff = Math.max(this.durability, 1);
      this.maxSpeed = this.baseMaxSpeed * (eff / 100);
      this.reloadTime = this.baseReloadTime * (100 / eff);
      this.bulletDamage = this.baseBulletDamage * (eff / 100);
      this.bulletPenetration = this.baseBulletPenetration * (eff / 100);
    }
    update() {
      if(!this.alive) return;
      this.recalcStats();
      if(this.speed) {
        let newX = this.x + Math.cos(this.rotate)*this.speed,
            newY = this.y + Math.sin(this.rotate)*this.speed;
        if(newX>=0 && newX<=worldWidth-this.size &&
           newY>=0 && newY<=worldHeight-this.size &&
           !collisionWithObstacles(newX, newY, this.size)) {
          this.x = newX; this.y = newY;
        }
      }
      if(this.reload>0) this.reload -= simStep;
      const cx = this.x+this.size/2, cy = this.y+this.size/2;
      this.body.position({ x: cx, y: cy });
      this.body.rotation((this.rotate*180)/Math.PI);
      this.barrel.position({ x: cx, y: cy });
      this.barrel.rotation((this.rotate*180)/Math.PI);
      if(!this.isPlayer) {
        let red = Math.floor(50+(this.durability/100)*205);
        this.body.fill(`rgb(${red},0,0)`);
      }
    }
    fire() {
      if(this.reload<=0 && this.alive) {
        this.reload = this.reloadTime;
        const cx = this.x+this.size/2, cy = this.y+this.size/2;
        return new Bullet(
          cx + Math.cos(this.rotate)*this.barrelLength,
          cy + Math.sin(this.rotate)*this.barrelLength,
          this.rotate,
          this.bulletDamage,
          this.bulletPenetration,
          this.isPlayer ? 'player' : 'enemy'
        );
      }
      return null;
    }
    takeHit(bullet) {
      if(!this.alive) return;
      if(Math.random()*100 < bullet.penetration) {
        const dmg = Math.floor((Math.random()*200+1)*bullet.damage);
        this.durability -= dmg;
      }
    }
    destroy() {
      this.body.destroy();
      this.barrel.destroy();
      this.alive = false;
    }
  }

  class Bullet {
    constructor(x, y, angle, damage, penetration, owner) {
      this.x = x;
      this.y = y;
      this.angle = angle;
      this.speed = 5;
      this.size = 5;
      this.damage = damage;
      this.penetration = penetration;
      this.owner = owner; // 'player' –∏–ª–∏ 'enemy'
      this.shape = new Konva.Circle({
        x: this.x, y: this.y, radius: this.size,
        fill: 'yellow'
      });
      worldGroup.add(this.shape);
    }
    update() {
      this.x += Math.cos(this.angle)*this.speed;
      this.y += Math.sin(this.angle)*this.speed;
      this.shape.position({ x: this.x, y: this.y });
    }
    destroy() {
      this.shape.destroy();
    }
  }

  class Bonus {
    constructor(x, y, type) {
      this.x = x; this.y = y; this.type = type;
      const colors = { reload:'#0ff', speed:'#0f0', durability:'#ff0', damage:'#f0f', penetration:'#f90' };
      this.shape = new Konva.Circle({
        x: this.x, y: this.y, radius: 10, fill: colors[type] || '#fff'
      });
      worldGroup.add(this.shape);
    }
    destroy() { this.shape.destroy(); }
  }

  class Obstacle {
    constructor(x, y, w, h) {
      this.x = x; this.y = y; this.width = w; this.height = h;
      this.shape = new Konva.Rect({
        x: this.x, y: this.y, width: w, height: h, fill: '#555'
      });
      worldGroup.add(this.shape);
    }
  }

  class Joystick {
    constructor(x, y, maxR) {
      this.x = x; this.y = y; this.maxRadius = maxR;
      this.base = new Konva.Circle({
        x: this.x, y: this.y, radius: this.maxRadius,
        stroke: '#fff', strokeWidth: 3, opacity: 0.5
      });
      layer.add(this.base);
      this.handle = new Konva.Circle({
        x: this.x, y: this.y, radius: 25, fill: '#fff', draggable: true
      });
      layer.add(this.handle);
      this.handle.on('dragmove', () => {
        let dx = this.handle.x()-this.x, dy = this.handle.y()-this.y;
        let dist = Math.hypot(dx,dy);
        if(dist > this.maxRadius) {
          let angle = Math.atan2(dy,dx);
          this.handle.x(this.x+Math.cos(angle)*this.maxRadius);
          this.handle.y(this.y+Math.sin(angle)*this.maxRadius);
        }
      });
      this.handle.on('dragend', () => {
        this.handle.to({ x: this.x, y: this.y, duration: 0.2 });
      });
    }
    getDirection() {
      return { x: this.handle.x()-this.x, y: this.handle.y()-this.y };
    }
  }

  /***********************
   * –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –∏–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
   ***********************/
  let score = 0;
  let lastBonusText = '–Ω–µ—Ç';
  let gameOver = false;
  // –î–ª—è —Ö–æ—Å—Ç–∞: playerTank ‚Äì —É–ø—Ä–∞–≤–ª—è–µ–º—ã–π –ª–æ–∫–∞–ª—å–Ω–æ; –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞: remoteTank ‚Äì –µ–≥–æ –ª–æ–∫–∞–ª—å–Ω—ã–π —Ç–∞–Ω–∫.
  let playerTank = new Tank(worldWidth/2 -15, worldHeight/2 -15, '#00f', true);
  let remoteTank = new Tank(playerTank.x - 100, playerTank.y, '#800080', true);
  // –ü—É–ª–∏ –∏–≥—Ä–æ–∫–æ–≤ (owner: 'player') –∏ –ø—É–ª–∏ –≤—Ä–∞–≥–æ–≤ (owner: 'enemy')
  let playerBullets = [];
  let enemyBullets = [];
  // –í—Ä–∞–∂–µ—Å–∫–∏–µ —Ç–∞–Ω–∫–∏ (–±–æ—Ç—ã) –∏ –±–æ–Ω—É—Å—ã ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ —Ö–æ—Å—Ç–∞
  let enemyTanks = [];
  let bonuses = [];
  let obstacles = [];

  // –§–ª–∞–≥–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è: –¥–ª—è —Ö–æ—Å—Ç–∞ ‚Äì firePressedLocal; –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞ ‚Äì –≤–≤–æ–¥ —á–µ—Ä–µ–∑ —Å–æ–æ–±—â–µ–Ω–∏—è
  let firePressedLocal = false;
  // –í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞
  let remoteInput = { dir: {x:0, y:0}, fire: false };

  // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Å–ø–∞–≤–Ω–∞ –≤—Ä–∞–≥–æ–≤
  let enemySpawnTimer = 0;
  let enemySpawnInterval = 30;

  /***********************
   * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–≥—Ä–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ (–Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ —Ö–æ—Å—Ç–∞)
   ***********************/
  function generateObstacles() {
    obstacles = [];
    let n = Math.floor(Math.random()*5)+3;
    for(let i=0; i<n; i++){
      let w = 100+Math.random()*100, h = 100+Math.random()*100;
      let x = Math.random()*(worldWidth-w), y = Math.random()*(worldHeight-h);
      if(Math.hypot((x+w/2)-(worldWidth/2), (y+h/2)-(worldHeight/2)) < 200) { i--; continue; }
      obstacles.push(new Obstacle(x, y, w, h));
    }
  }
  function spawnEnemyTank() {
    const margin = 50, size = 30;
    let side = Math.floor(Math.random()*4), x, y;
    if(side===0){ x = Math.random()*(worldWidth-2*margin-size)+margin; y = margin; }
    else if(side===1){ x = worldWidth-margin-size; y = Math.random()*(worldHeight-2*margin-size)+margin; }
    else if(side===2){ x = Math.random()*(worldWidth-2*margin-size)+margin; y = worldHeight-margin-size; }
    else { x = margin; y = Math.random()*(worldHeight-2*margin-size)+margin; }
    enemyTanks.push(new Tank(x, y, '#f00', false));
  }

  function rectsIntersect(x1,y1,w1,h1, x2,y2,w2,h2){
    return !(x2>x1+w1 || x2+w2<x1 || y2>y1+h1 || y2+h2<y1);
  }
  function collisionWithObstacles(newX, newY, size) {
    for(let obs of obstacles){
      if(rectsIntersect(newX,newY,size,size, obs.x,obs.y, obs.width, obs.height))
        return true;
    }
    return false;
  }
  function bulletHitsObstacle(bullet) {
    for(let obs of obstacles) {
      if(bullet.x>obs.x && bullet.x<obs.x+obs.width &&
         bullet.y>obs.y && bullet.y<obs.y+obs.height)
         return true;
    }
    return false;
  }
  // –ï—Å–ª–∏ –ø—É–ª—è –ø–æ–ø–∞–¥–∞–µ—Ç –≤ —Ç–∞–Ω–∫ (–∏ –ø—É–ª—è –Ω–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —Ç–æ–º—É –∂–µ –∏–≥—Ä–æ–∫—É)
  function checkBulletCollision(bullet, tank) {
    let dx = bullet.x - (tank.x+tank.size/2);
    let dy = bullet.y - (tank.y+tank.size/2);
    if(Math.hypot(dx,dy) < tank.size/2 + bullet.size) {
      if(bullet.owner==='enemy' || (bullet.owner==='player' && tank !== bullet.firedBy))
        return true;
    }
    return false;
  }

  // –ü—Ä–∏ —Å–º–µ—Ä—Ç–∏ –∏–≥—Ä–æ–∫–∞ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –±–æ–Ω—É—Å –∏ —É–¥–∞–ª—è–µ–º —Ç–∞–Ω–∫
  function dropBonusAt(x, y) {
    const bonusTypes = ['reload','speed','durability','damage','penetration'];
    let type = bonusTypes[Math.floor(Math.random()*bonusTypes.length)];
    bonuses.push(new Bonus(x, y, type));
  }
  function applyBonus(type) {
    if(playerTank.alive && playerTank.durability > 0) {
      switch(type) {
        case 'reload': playerTank.baseReloadTime *= 0.85; break;
        case 'speed': playerTank.baseMaxSpeed *= 1.15; break;
        case 'durability': playerTank.durability += 10; break;
        case 'damage': playerTank.baseBulletDamage *= 1.35; break;
        case 'penetration': playerTank.baseBulletPenetration += 10; break;
      }
    }
    if(remoteTank.alive && remoteTank.durability > 0) {
      switch(type) {
        case 'reload': remoteTank.baseReloadTime *= 0.85; break;
        case 'speed': remoteTank.baseMaxSpeed *= 1.15; break;
        case 'durability': remoteTank.durability += 10; break;
        case 'damage': remoteTank.baseBulletDamage *= 1.35; break;
        case 'penetration': remoteTank.baseBulletPenetration += 10; break;
      }
    }
  }

  /***********************
   * Multiplayer —á–µ—Ä–µ–∑ PeerJS
   ***********************/
  const hostId = "tankBattleHost";
  let isHost = false;
  let conn = null;
  let peer;
  try { peer = new Peer(null, { debug: 2 }); }
  catch(e){ console.log("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ Peer:", e); }

  function sendMessage(msg) {
    if(conn && conn.open) { conn.send(JSON.stringify(msg)); }
  }
  function handleMessage(data) {
    try {
      const msg = JSON.parse(data);
      if(msg.type==='state'){
        updateGameState(msg.data);
      }
      else if(msg.type==='input'){
        remoteInput = msg.data;
      }
    } catch(e){ console.log("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è:", e); }
  }
  function sendInput(input) { sendMessage({ type:'input', data: input }); }
  function updateGameState(state) {
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–±–æ–∏—Ö —Ç–∞–Ω–∫–æ–≤
    if(state.playerTank.durability < 1) {
      if(playerTank.alive) playerTank.destroy();
    } else {
      playerTank.x = state.playerTank.x;
      playerTank.y = state.playerTank.y;
      playerTank.rotate = state.playerTank.rotate;
      playerTank.durability = state.playerTank.durability;
      if(playerTank.alive) playerTank.update();
    }
    if(state.remoteTank.durability < 1) {
      if(remoteTank.alive) remoteTank.destroy();
    } else {
      remoteTank.x = state.remoteTank.x;
      remoteTank.y = state.remoteTank.y;
      remoteTank.rotate = state.remoteTank.rotate;
      remoteTank.durability = state.remoteTank.durability;
      if(remoteTank.alive) remoteTank.update();
    }
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—É–ª–∏ –∏–≥—Ä–æ–∫–æ–≤
    playerBullets.forEach(b => b.destroy());
    playerBullets = [];
    for(let bData of state.playerBullets) {
      let b = new Bullet(bData.x, bData.y, bData.angle, bData.damage, bData.penetration, bData.owner);
      b.speed = bData.speed; b.firedBy = bData.firedBy;
      playerBullets.push(b);
    }
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—É–ª–∏ –≤—Ä–∞–≥–æ–≤
    enemyBullets.forEach(b => b.destroy());
    enemyBullets = [];
    for(let bData of state.enemyBullets) {
      let b = new Bullet(bData.x, bData.y, bData.angle, bData.damage, bData.penetration, bData.owner);
      b.speed = bData.speed;
      enemyBullets.push(b);
    }
    // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–∞–≥–æ–≤
    enemyTanks.forEach(t => t.destroy());
    enemyTanks = [];
    for(let tData of state.enemyTanks) {
      let t = new Tank(tData.x, tData.y, '#f00', false);
      t.rotate = tData.rotate; t.durability = tData.durability;
      enemyTanks.push(t);
    }
    // –û–±–Ω–æ–≤–ª—è–µ–º –±–æ–Ω—É—Å—ã
    bonuses.forEach(b => b.destroy());
    bonuses = [];
    for(let bData of state.bonuses) {
      bonuses.push(new Bonus(bData.x, bData.y, bData.type));
    }
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è ‚Äì —É–Ω–∏—á—Ç–æ–∂–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∏ —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–µ
    obstacles.forEach(o => o.shape.destroy());
    obstacles = [];
    for(let oData of state.obstacles) {
      obstacles.push(new Obstacle(oData.x, oData.y, oData.width, oData.height));
    }
    score = state.score;
    lastBonusText = state.lastBonus;
  }
  function getGameState() {
    return {
      playerTank: { x: playerTank.x, y: playerTank.y, rotate: playerTank.rotate, durability: playerTank.durability },
      remoteTank: { x: remoteTank.x, y: remoteTank.y, rotate: remoteTank.rotate, durability: remoteTank.durability },
      playerBullets: playerBullets.map(b => ({
        x: b.x, y: b.y, angle: b.angle, speed: b.speed,
        damage: b.damage, penetration: b.penetration,
        owner: b.owner, firedBy: b.firedBy || (b.owner==='player' ? 'host' : 'client')
      })),
      enemyBullets: enemyBullets.map(b => ({
        x: b.x, y: b.y, angle: b.angle, speed: b.speed,
        damage: b.damage, penetration: b.penetration, owner: b.owner
      })),
      enemyTanks: enemyTanks.map(t => ({
        x: t.x, y: t.y, rotate: t.rotate, durability: t.durability
      })),
      bonuses: bonuses.map(b => ({
        x: b.shape.x(), y: b.shape.y(), type: b.type
      })),
      obstacles: obstacles.map(o => ({
        x: o.x, y: o.y, width: o.width, height: o.height
      })),
      score: score,
      lastBonus: lastBonusText
    };
  }

  /***********************
   * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è PeerJS
   ***********************/
  peer.on('open', id => {
    console.log('–ú–æ–π peer id: ' + id);
    let tempConn = peer.connect(hostId, { reliable: true });
    let timeout = setTimeout(() => {
      if(!conn || !conn.open) {
        console.log("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å host –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –∑–∞ 5 —Å–µ–∫, —Å—Ç–∞–Ω–æ–≤–ª—é—Å—å —Ö–æ—Å—Ç–æ–º");
        becomeHost();
      }
    }, 5000);
    tempConn.on('open', () => {
      clearTimeout(timeout);
      console.log("–ü–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ host –∫–∞–∫ –∫–ª–∏–µ–Ω—Ç");
      conn = tempConn;
      conn.on('data', handleMessage);
      startGame();
    });
    tempConn.on('error', err => {
      console.log("–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ host:", err);
      clearTimeout(timeout);
      becomeHost();
    });
  });
  function becomeHost() {
    isHost = true;
    peer.destroy();
    try { peer = new Peer(hostId, { debug: 2 }); }
    catch(e){ console.log("–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è host Peer:", e); }
    peer.on('open', id => {
      console.log("–Ø —Ö–æ—Å—Ç, id: " + id);
      showMessage("–û–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–∞‚Ä¶");
      generateObstacles();
    });
    peer.on('connection', connection => {
      conn = connection;
      conn.on('data', handleMessage);
      console.log("–ö –Ω–∞–º –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è –∫–ª–∏–µ–Ω—Ç");
      hideMessage();
      startGame();
    });
  }

  /***********************
   * –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
   ***********************/
  // gameLoop —Ä–∞–±–æ—Ç–∞–µ—Ç —Å desiredFPS = 15
  function gameLoop(timestamp) {
    let delta = timestamp - lastFrameTime;
    if(delta >= 1000/desiredFPS) {
      lastFrameTime = timestamp;
      if(isHost) { hostSimulation(); }
      renderGame();
      if(!isHost) {
        let d = joystick.getDirection();
        sendInput({ dir: d, fire: firePressedLocal });
        firePressedLocal = false;
      }
      updateFPS(delta);
    }
    requestAnimationFrame(gameLoop);
  }
  function updateFPS(delta) {
    document.getElementById('fpsDisplay').innerText = (1000/delta).toFixed(1);
  }

  /***********************
   * –°–∏–º—É–ª—è—Ü–∏—è –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ —Ö–æ—Å—Ç–∞
   ***********************/
  function hostSimulation() {
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ —Ö–æ—Å—Ç–∞
    let d = joystick.getDirection();
    let mag = Math.hypot(d.x, d.y);
    if(mag > 0) {
    playerTank.speed = (mag * playerTank.maxSpeed)/joystick.maxRadius;
      playerTank.rotate = Math.atan2(d.y, d.x);
    } else { playerTank.speed = 0; }
    playerTank.update();
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –∫–ª–∏–µ–Ω—Ç–∞ –¥–ª—è remoteTank
    let r = remoteInput.dir;
    let rMag = Math.hypot(r.x, r.y);
    if(rMag > 0) {
      remoteTank.speed = (rMag * remoteTank.maxSpeed)/joystick.maxRadius;
      remoteTank.rotate = Math.atan2(r.y, r.x);
    } else { remoteTank.speed = 0; }
    remoteTank.update();
    // –°—Ç—Ä–µ–ª—å–±–∞ —Ö–æ—Å—Ç–∞
    if(firePressedLocal) {
      let b = playerTank.fire();
      if(b) { b.firedBy = playerTank; playerBullets.push(b); }
      firePressedLocal = false;
    }
    // –°—Ç—Ä–µ–ª—å–±–∞ –∫–ª–∏–µ–Ω—Ç–∞
    if(remoteInput.fire) {
      let b = remoteTank.fire();
      if(b) { b.firedBy = remoteTank; playerBullets.push(b); }
      remoteInput.fire = false;
    }
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—É–ª—å –∏–≥—Ä–æ–∫–æ–≤
    for(let i = playerBullets.length-1; i>=0; i--) {
      let b = playerBullets[i];
      b.update();
      if(b.owner==='player') {
        // –ï—Å–ª–∏ –ø—É–ª—è –æ—Ç —Ö–æ—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ø–∞–¥–∞–Ω–∏–µ –≤ remoteTank; –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞ ‚Äì –≤ playerTank
        if(b.firedBy === playerTank && remoteTank.alive && checkBulletCollision(b, remoteTank)) {
          remoteTank.takeHit(b);
          b.destroy(); playerBullets.splice(i,1); continue;
        }
        if(b.firedBy === remoteTank && playerTank.alive && checkBulletCollision(b, playerTank)) {
          playerTank.takeHit(b);
          b.destroy(); playerBullets.splice(i,1); continue;
        }
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –≤—Ä–∞–∂–µ—Å–∫–∏–º–∏ —Ç–∞–Ω–∫–∞–º–∏ (–±–æ—Ç–∞–º–∏)
        for(let j = 0; j < enemyTanks.length; j++) {
          let et = enemyTanks[j];
          if(et.alive && checkBulletCollision(b, et)) {
            et.takeHit(b);
            b.destroy(); playerBullets.splice(i,1);
            break;
          }
        }
      }
      if(b.x<0 || b.x>worldWidth || b.y<0 || b.y>worldHeight || bulletHitsObstacle(b)) {
        b.destroy(); playerBullets.splice(i,1);
      }
    }
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—É–ª—å –≤—Ä–∞–≥–æ–≤
    for(let i = enemyBullets.length-1; i>=0; i--){
      let b = enemyBullets[i];
      b.update();
      if(playerTank.alive && checkBulletCollision(b, playerTank)) {
        playerTank.takeHit(b);
        b.destroy(); enemyBullets.splice(i,1); continue;
      }
      if(remoteTank.alive && checkBulletCollision(b, remoteTank)) {
        remoteTank.takeHit(b);
        b.destroy(); enemyBullets.splice(i,1); continue;
      }
      if(b.x<0 || b.x>worldWidth || b.y<0 || b.y>worldHeight || bulletHitsObstacle(b)){
        b.destroy(); enemyBullets.splice(i,1);
      }
    }
    // –°–ø–∞–≤–Ω –≤—Ä–∞–≥–æ–≤ (–±–æ—Ç–æ–≤)
    enemySpawnTimer += simStep;
    if(enemySpawnTimer > enemySpawnInterval) {
      spawnEnemyTank();
      enemySpawnTimer = 0;
      enemySpawnInterval = 10 + Math.random()*10;
    }
    enemyTanks.forEach((t, idx) => {
      t.rotate += (Math.random()-0.5)*0.05;
      t.speed = t.maxSpeed;
      t.update();
      if(t.reload<=0) {
        // –í—ã–±–∏—Ä–∞–µ–º —Ü–µ–ª—å: –±–ª–∏–∂–∞–π—à–∏–π –∏–∑ –∂–∏–≤—ã—Ö –∏–≥—Ä–æ–∫–æ–≤ (–µ—Å–ª–∏ –æ–±–∞ –∂–∏–≤—ã, –∏–Ω–∞—á–µ —Ç–æ—Ç, –∫—Ç–æ –∂–∏–≤)
        let target = null;
        if(playerTank.alive && remoteTank.alive) {
          let d1 = Math.hypot(playerTank.x - t.x, playerTank.y - t.y);
          let d2 = Math.hypot(remoteTank.x - t.x, remoteTank.y - t.y);
          target = (d1 <= d2) ? playerTank : remoteTank;
        } else if(playerTank.alive) {
          target = playerTank;
        } else if(remoteTank.alive) {
          target = remoteTank;
        }
        if(target) {
          let angleToTarget = Math.atan2((target.y+target.size/2)-(t.y+t.size/2),
                                          (target.x+target.size/2)-(t.x+t.size/2));
          t.rotate = angleToTarget;
          let b = t.fire();
          if(b) { b.firedBy = t; enemyBullets.push(b); }
        }
      }
      if(t.durability < 1) {
        dropBonusAt(t.x+t.size/2, t.y+t.size/2);
        t.destroy(); enemyTanks.splice(idx,1); score++;
      }
    });
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –±–æ–Ω—É—Å–æ–≤ ‚Äì –ø–æ–¥–±–∏—Ä–∞—é—Ç —Ç–æ–ª—å–∫–æ –∂–∏–≤—ã–µ –∏–≥—Ä–æ–∫–∏
    bonuses.forEach((b, idx) => {
      if(playerTank.alive) {
        let dx = b.shape.x() - (playerTank.x+playerTank.size/2),
            dy = b.shape.y() - (playerTank.y+playerTank.size/2);
        if(Math.hypot(dx,dy) < playerTank.size/2+10) {
          applyBonus(b.type); lastBonusText = b.type;
          b.destroy(); bonuses.splice(idx,1);
          return;
        }
      }
      if(remoteTank.alive) {
        let dx = b.shape.x() - (remoteTank.x+remoteTank.size/2),
            dy = b.shape.y() - (remoteTank.y+remoteTank.size/2);
        if(Math.hypot(dx,dy) < remoteTank.size/2+10) {
          applyBonus(b.type); lastBonusText = b.type;
          b.destroy(); bonuses.splice(idx,1);
          return;
        }
      }
    });
    // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ —É–º–∏—Ä–∞–µ—Ç ‚Äì —É–¥–∞–ª—è–µ–º –µ–≥–æ –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –±–æ–Ω—É—Å (—Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑)
    if(playerTank.alive && playerTank.durability < 1) {
      dropBonusAt(playerTank.x+playerTank.size/2, playerTank.y+playerTank.size/2);
      playerTank.destroy(); score++;
    }
    if(remoteTank.alive && remoteTank.durability < 1) {
      dropBonusAt(remoteTank.x+remoteTank.size/2, remoteTank.y+remoteTank.size/2);
      remoteTank.destroy(); score++;
    }
    // –ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è, –∫–æ–≥–¥–∞ –æ–±–∞ –∏–≥—Ä–æ–∫–∞ –º–µ—Ä—Ç–≤—ã
    if(!playerTank.alive && !remoteTank.alive) {
      alert("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞. –°—á—ë—Ç: " + score);
      gameOver = true;
    }
    // –ù–∞ –∫–∞–∂–¥–æ–º —Ü–∏–∫–ª–µ —Ö–æ—Å—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã –∫–ª–∏–µ–Ω—Ç—É
    sendMessage({ type:'state', data: getGameState() });
  }

  /***********************
   * –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
   ***********************/
  function renderGame() {
    // –ö–∞–º–µ—Ä–∞ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–µ—Ä—É—Ç—Å—è –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ç–∞–Ω–∫–∞:
    // –î–ª—è —Ö–æ—Å—Ç–∞ ‚Äì playerTank, –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞ ‚Äì remoteTank
    let localTank = isHost ? playerTank : remoteTank;
    if(localTank && localTank.alive) {
      const scale = 0.6;
      worldGroup.scale({ x: scale, y: scale });
      let offsetX = viewWidth/2 - (localTank.x+localTank.size/2)*scale;
      let offsetY = viewHeight/2 - (localTank.y+localTank.size/2)*scale;
      const minOffsetX = viewWidth - worldWidth*scale,
            minOffsetY = viewHeight - worldHeight*scale;
      offsetX = Math.min(0, Math.max(minOffsetX, offsetX));
      offsetY = Math.min(0, Math.max(minOffsetY, offsetY));
      worldGroup.position({ x: offsetX, y: offsetY });
    }
    // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ç–∞–Ω–∫–∞
    let statsText = (localTank && localTank.alive) ?
      `–ü—Ä–æ—á–Ω–æ—Å—Ç—å: ${localTank.durability.toFixed(0)}<br>
       –°–∫–æ—Ä–æ—Å—Ç—å: ${localTank.maxSpeed.toFixed(2)}<br>
       –ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞: ${localTank.reloadTime.toFixed(2)}<br>
       –°–∏–ª–∞ —Å–Ω–∞—Ä—è–¥–∞: ${(localTank.bulletDamage*100).toFixed(0)}%<br>
       –ü—Ä–æ–±–∏–≤–∞–µ–º–æ—Å—Ç—å: ${localTank.bulletPenetration.toFixed(0)}%`
      : "–í—ã –º–µ—Ä—Ç–≤—ã";
    document.getElementById('playerStats').innerHTML = statsText;
    document.getElementById('score').innerText = Math.floor(score);
    document.getElementById('lastBonus').innerText = lastBonusText;
    layer.batchDraw();
  }

  /***********************
   * –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
   ***********************/
  const joystick = new Joystick(80, viewHeight-80, 65);
  firePressedLocal = false;
  document.getElementById('fireBtn').addEventListener('touchstart', () => { firePressedLocal = true; });
  document.getElementById('fireBtn').addEventListener('mousedown', () => { firePressedLocal = true; });
  document.getElementById('backBtn').addEventListener('click', () => { window.location.href = 'glist.html'; });

  /***********************
   * –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
   ***********************/
  function showMessage(text) {
    const m = document.getElementById('message');
    m.innerText = text; m.style.display = 'block';
  }
  function hideMessage() { document.getElementById('message').style.display = 'none'; }
  function startGame() {
    hideMessage();
    requestAnimationFrame(gameLoop);
  }
  requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
