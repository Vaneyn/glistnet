<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Хойка</title>
<style>
  :root{
    --bg:#08111a;
    --panel:#0f1720;
    --muted:#9aa4b2;
    --accent:#5ad3a1;
    --danger:#ff6b6b;
    --glass: rgba(255,255,255,0.03);
    font-family: Inter, Roboto, Arial, sans-serif;
    --pad: 12px;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071019);color:#e6eef6;}
  .app{max-width:980px;margin:0 auto;padding:12px;box-sizing:border-box;min-height:100vh;display:flex;flex-direction:column;gap:12px;}
  header{display:flex;gap:8px;align-items:center;justify-content:space-between;}
  h1{font-size:16px;margin:0;}
  .controls{display:flex;gap:8px;align-items:center;}
  button{background:var(--glass);border:1px solid rgba(255,255,255,0.03);color:inherit;padding:8px 10px;border-radius:10px;font-size:14px;}
  .btn-strong{background:linear-gradient(90deg,var(--accent),#3fbf8a);color:#06201a;border:none;box-shadow:0 6px 18px rgba(0,0,0,0.4);}
  .btn-danger{background:linear-gradient(90deg,var(--danger),#d74b4b);color:#2b0707;border:none;}
  main{display:flex;gap:12px;flex:1;flex-direction:column;}
  .row{display:flex;gap:12px;}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);}
  .left{flex:1;min-width:220px;}
  .right{width:380px;max-width:45%;min-width:220px;display:flex;flex-direction:column;gap:12px;}
  .stat{display:flex;justify-content:space-between;gap:12px;padding:8px 0;border-bottom:1px dashed rgba(255,255,255,0.02);}
  .big{font-size:20px;font-weight:700;}
  .small{font-size:12px;color:var(--muted);}
  .countries-list{max-height:320px;overflow:auto;padding-right:6px;}
  .country-item{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;margin-bottom:6px;background:rgba(255,255,255,0.01);}
  .actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;}
  .log{max-height:220px;overflow:auto;background:rgba(0,0,0,0.08);padding:8px;border-radius:8px;font-size:13px;}
  .footer{display:flex;justify-content:space-between;align-items:center;}
  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.6);Display:flex;align-items:center;justify-content:center;z-index:9999;}
  .modal{background:#07121a;padding:14px;border-radius:12px;width:92%;max-width:520px;border:1px solid rgba(255,255,255,0.04);}
  .modal h3{margin:0 0 8px 0;}
  .row-between{display:flex;justify-content:space-between;align-items:center;}
  .pie{
    width:120px;height:120px;border-radius:50%;display:flex;align-items:center;justify-content:center;
    background: conic-gradient(var(--accent) 0deg 180deg, rgba(255,255,255,0.04) 180deg 360deg);
    box-shadow: inset 0 -6px 18px rgba(0,0,0,0.2);
  }
  input[type="range"]{width:100%;}
  label.small{display:block;margin-bottom:6px;}
  
  /* Стили для окна битвы */
  .battle-modal{max-width:600px;}
  .battle-container{display:flex;justify-content:space-between;gap:20px;margin:20px 0;}
  .army-column{display:flex;flex-direction:column;align-items:center;flex:1;}
  .army-bar-container{width:80px;height:200px;background:rgba(255,255,255,0.05);border-radius:6px;overflow:hidden;position:relative;}
  .army-bar{position:absolute;bottom:0;width:100%;background:linear-gradient(to top, var(--accent), #3fbf8a);transition:height 0.1s linear;}
  .army-bar.defender{background:linear-gradient(to top, var(--danger), #d74b4b);}
  .army-info{margin-top:10px;text-align:center;}
  .army-name{font-weight:600;margin-bottom:4px;}
  .army-count{font-size:14px;color:var(--muted);}
  .battle-results{margin-top:20px;padding:12px;background:rgba(255,255,255,0.02);border-radius:8px;display:none;}
  .battle-timeline{height:4px;background:rgba(255,255,255,0.1);border-radius:2px;margin:15px 0;position:relative;}
  .battle-progress{position:absolute;left:0;top:0;height:100%;background:var(--accent);border-radius:2px;width:0%;transition:width 5s linear;}
  
  @media (max-width:820px){.row{flex-direction:column;} .right{width:100%}}
  button, .country-item { touch-action: manipulation; }
</style>
</head>
<body>
<div class="app">
  <header>
    <div style="display:flex;align-items:center;gap:8px;">
      <a href="glist.html"><button title="Назад в G-list">← Назад</button></a>
      
      <div class="small" style="margin-left:8px;color:var(--muted)">1 ход = 1 месяц </div>
    </div>
    <div class="controls">
      <button id="btnNext" class="btn-strong">Следующий месяц</button>
      <button id="btnReset" title="Сброс игры">Сброс</button>
    </div>
  </header>

  <main>
    <div class="row">
      <section class="panel left">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <div id="playerName" class="big">Страна игрока</div>
            <div class="small">Ты управляешь одной из 10 стран. Боты — остальные 9.</div>
            <div class="small" id="peacePeriodInfo" style="color:#ffa726;margin-top:4px;"></div>
          </div>
          <div style="text-align:right">
            <div class="small">Ход: <span id="turnNumber">0</span></div>
          </div>
        </div>

        <hr style="opacity:0.06;border:none;height:8px">
        <div id="playerStats"></div>

        <div class="actions">
          <button id="buildFactory">Построить завод (1 000 000$)</button>
          <button id="attackBtn">Атаковать страну</button>
          <button id="mobilizeBtn">Мобилизовать</button>
        </div>

        <h3 style="margin-top:12px;margin-bottom:8px">Журнал</h3>
        <div id="log" class="log"></div>
      </section>

      <aside class="panel right">
        <div>
          <div class="small">Список стран (Боты)</div>
          <div class="countries-list" id="countriesList"></div>
        </div>

        <div style="margin-top:8px">
          <div class="small">Краткие правила</div>
          <ul style="padding-left:18px;margin:6px 0 0 0;color:var(--muted)">
           <li>Политическая атака: при достижении порога 0.1% населения — теряется 1 завод</li>
            <li>Экономическая атака: при том же пороге — теряется 2–5 заводов и гибнет 0.75–1.75% мирного населения</li>
          </ul>
        </div>
      </aside>
    </div>

    <div class="panel" style="display:flex;gap:12px;flex-direction:column;">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div class="small">Текущее состояние всех стран (суммарно)</div>
        <div class="small" id="summaryAll"></div>
      </div>
      <div id="allStats" style="display:flex;gap:12px;flex-wrap:wrap;margin-top:8px;"></div>
      <div class="footer" style="margin-top:8px">
        <div class="small">Игра локальная — сохраняется в localStorage.</div>
        <div><button id="saveBtn">Сохранить сейчас</button></div>
      </div>
    </div>
  </main>
</div>

<script>
(function(){
  // Константы
  const POPULATION = 100_00; // начальное население у всех
  const FACTORIES_START = 10;
  const FACTORY_INCOME = 20_000; // $ в месяц с завода
  const ARMY_PERCENT = 0.09; // 10% населения изначально
  const ARMY_COST_PER = 500; // $ в месяц на человека
  const TAX_PER_PERSON = 30; // $ в месяц
  const FACTORY_COST = 1_000_000; // стоимость строительства завода
  const MOBILIZE_COST = 2_000; // $ за мобилизацию 1 человека

  // state
  let state = { turn: 0, countries: [], pendingRetaliations: [], attacksThisTurn: {} };

  // утилиты
  function fmt(n){ return Number(n).toLocaleString('ru-RU', {maximumFractionDigits:0}); }
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function randFloat(a,b){ return a + Math.random()*(b-a); }

  function makeCountry(index, isPlayer=false){
    const pop = POPULATION;
    const country = {
      id: index,
      name: isPlayer? 'Твоя страна' : ('Страна ' + index),
      population: pop,
      factories: FACTORIES_START,
      army: Math.round(pop * ARMY_PERCENT),
      balance: 0,
      isPlayer: !!isPlayer
    };
    
    if (!isPlayer) {
      // Для ботов добавляем параметры агрессивности
      country.aggressiveness = randFloat(0.01, 0.99); // Случайная агрессивность
      country.martialLaw = 0; // 0 = нет военного положения, >0 = оставшиеся месяцы
      country.militaryFund = 0; // Фонд на военные расходы
      country.factoryFund = 0; // Фонд на заводы
    }
    
    return country;
  }

  function initIfEmpty(){
    const saved = localStorage.getItem('countries_game_v5');
    if (saved){
      try {
        state = JSON.parse(saved);
        // ensure arrays/props exist after load
        state.countries = state.countries.map((c, idx) => {
          c.id = c.id ?? idx+1;
          c.population = c.population ?? POPULATION;
          c.factories = c.factories ?? FACTORIES_START;
          c.army = c.army ?? Math.round((c.population||POPULATION)*ARMY_PERCENT);
          c.balance = c.balance ?? 0;
          c.isPlayer = !!c.isPlayer;
          c.name = c.name ?? (c.isPlayer ? 'Твоя страна' : 'Страна ' + c.id);
          
          // Добавляем новые свойства для ботов, если их нет
          if (!c.isPlayer) {
            c.aggressiveness = c.aggressiveness ?? randFloat(0.01, 0.99);
            c.martialLaw = c.martialLaw ?? 0;
            c.militaryFund = c.militaryFund ?? 0;
            c.factoryFund = c.factoryFund ?? 0;
          }
          return c;
        });
        state.pendingRetaliations = state.pendingRetaliations ?? [];
        state.attacksThisTurn = state.attacksThisTurn ?? {};
        return;
      } catch(e){
        console.warn('Ошибка чтения сохранения — создаём новую игру.', e);
      }
    }
    state = { turn: 0, countries: [], pendingRetaliations: [], attacksThisTurn: {} };
    for (let i=1;i<=10;i++) state.countries.push(makeCountry(i, i===1));
    saveState();
  }

  function saveState(){
    localStorage.setItem('countries_game_v5', JSON.stringify(state));
  }

  // месячный дельта (налоги/заводы/армия)
  function monthlyDelta(country){
    const taxes = Math.round(country.population * TAX_PER_PERSON);
    const factoryIncome = country.factories * FACTORY_INCOME;
    const armyCost = Math.round(country.army * ARMY_COST_PER);
    return { taxes, factoryIncome, armyCost, net: taxes + factoryIncome - armyCost };
  }

  // Проверка возможности мобилизации (доход должен остаться положительным)
  function canMobilize(country, numToMobilize = 1) {
    if (country.isPlayer) return true;
    
    const m = monthlyDelta(country);
    const futureArmyCost = (country.army + numToMobilize) * ARMY_COST_PER;
    const futureNet = m.taxes + m.factoryIncome - futureArmyCost;
    return futureNet > 0;
  }

  // Автоматическая демобилизация если доход отрицательный
  function autoDemobilize(country) {
    if (country.isPlayer) return 0;
    
    let demobilized = 0;
    let m = monthlyDelta(country);
    
    while (m.net < 0 && country.army > 0) {
      country.army -= 1;
      demobilized += 1;
      m = monthlyDelta(country);
    }
    
    if (demobilized > 0) {
      addLog(`${country.name} демобилизовала ${fmt(demobilized)} солдат из-за отрицательного дохода.`);
    }
    
    return demobilized;
  }

  // Логика ботов
  function botLogic(bot) {
    if (bot.population <= 0) return; // Пропускаем уничтоженные страны
    
    // Автоматическая демобилизация если нужно
    autoDemobilize(bot);
    
    // Обновляем военное положение
    if (bot.martialLaw > 0) {
      bot.martialLaw--;
    }
    
    // Получаем текущий доход
    const m = monthlyDelta(bot);
    const income = m.net;
    
    if (income <= 0) return; // Если доход отрицательный, ничего не делаем
    
    // Распределяем доход по фондам
    let militaryShare = bot.aggressiveness;
    let factoryShare = 1 - militaryShare;
    
    // Военное положение меняет распределение
    if (bot.martialLaw > 0) {
      factoryShare /= 2;
      militaryShare = 1 - factoryShare;
      
      // При военном положении все свободные средства идут на военные расходы
      if (bot.balance > 0) {
        bot.militaryFund += bot.balance;
        bot.balance = 0;
      }
    }
    
    // Распределяем текущий доход
    bot.militaryFund += income * militaryShare;
    bot.factoryFund += income * factoryShare;
    
    // 1. Мобилизация из военного фонда
    // Целевой процент мобилизации: теперь равен агрессивности
    const targetArmyPercent = bot.aggressiveness;
    const targetArmy = Math.round(bot.population * targetArmyPercent);
    
    if (bot.martialLaw > 0) {
      // Неограниченная мобилизация в военном положении, ограничиваемся только положительным доходом и доступными гражданами/фондом
      const civilians = Math.max(0, bot.population - bot.army);
      const maxByFund = Math.floor(bot.militaryFund / MOBILIZE_COST);
      const maxByCivilians = civilians;
      let maxByIncome = 0;
      if (monthlyDelta(bot).net > 0) {
        maxByIncome = Math.floor((monthlyDelta(bot).net - 1) / ARMY_COST_PER);
      }
      const toMobilize = Math.min(maxByFund, maxByCivilians, maxByIncome);
      if (toMobilize > 0 && canMobilize(bot, toMobilize)) {
        const cost = toMobilize * MOBILIZE_COST;
        bot.militaryFund -= cost;
        bot.army += toMobilize;
        if (state.turn % 5 === 0) addLog(`${bot.name} мобилизовала ${fmt(toMobilize)} солдат (в военном положении).`);
      }
    } else {
      if (bot.army < targetArmy) {
        const needed = targetArmy - bot.army;
        const maxByFund = Math.floor(bot.militaryFund / MOBILIZE_COST);
        const civilians = Math.max(0, bot.population - bot.army);
        const maxByCivilians = civilians;
        let maxByIncome = 0;
        if (monthlyDelta(bot).net > 0) {
          maxByIncome = Math.floor((monthlyDelta(bot).net - 1) / ARMY_COST_PER);
        }
        const toMobilize = Math.min(needed, maxByFund, maxByCivilians, maxByIncome);
        if (toMobilize > 0 && canMobilize(bot, toMobilize)) {
          const cost = toMobilize * MOBILIZE_COST;
          bot.militaryFund -= cost;
          bot.army += toMobilize;
          if (state.turn % 5 === 0) addLog(`${bot.name} мобилизовала ${fmt(toMobilize)} солдат.`);
        }
      }
    }
    
    // Неиспользованные средства из военного фонда идут в баланс
    bot.balance += bot.militaryFund;
    bot.militaryFund = 0;
    
    // 2. Строительство заводов из заводского фонда
    while (bot.factoryFund >= FACTORY_COST) {
      bot.factoryFund -= FACTORY_COST;
      bot.factories += 1;
      if (state.turn % 3 === 0) addLog(`${bot.name} построила завод.`);
    }
    
    // 3. Новое правило: если денег больше чем доход в месяц * 5, отправляем лишнее в фонд заводов (кроме военного положения)
    if (bot.martialLaw === 0) {
      const monthlyNet = monthlyDelta(bot).net;
      if (monthlyNet > 0 && bot.balance > monthlyNet * 5) {
        const excess = bot.balance - (monthlyNet * 5);
        bot.factoryFund += excess;
        bot.balance -= excess;
      }
    }
    
    // 4. Логика атаки (оставляем прежней)
    if (state.turn >= 2 && bot.army > 0 && Math.random() < 0.3) {
      // Ищем самую слабую страну
      let weakest = null;
      let minArmy = Infinity;
      
      for (let other of state.countries) {
        if (other === bot || other.population <= 0) continue;
        if (other.army < minArmy) {
          minArmy = other.army;
          weakest = other;
        }
      }
      
      if (weakest && weakest.army < bot.army) {
        const weaknessFactor = (bot.army - weakest.army) / bot.army;
        const probability = bot.aggressiveness * 10 * Math.max(0.01, weaknessFactor);
        
        if (Math.random() < probability / 100) {
          const attackTroops = Math.max(1, Math.round(bot.army * bot.aggressiveness));
          const isEconomic = bot.aggressiveness > 0.9;
          
          // боты вызывают simulateAttack но не ждут (так было изначально)
          simulateAttack(bot, weakest, Math.min(attackTroops, bot.army), isEconomic);
        }
      }
    }
  }

  // UI refs
  const turnNumber = document.getElementById('turnNumber');
  const playerStats = document.getElementById('playerStats');
  const countriesList = document.getElementById('countriesList');
  const btnNext = document.getElementById('btnNext');
  const btnReset = document.getElementById('btnReset');
  const buildFactoryBtn = document.getElementById('buildFactory');
  const attackBtn = document.getElementById('attackBtn');
  const mobilizeBtn = document.getElementById('mobilizeBtn');
  const logEl = document.getElementById('log');
  const playerName = document.getElementById('playerName');
  const allStats = document.getElementById('allStats');
  const summaryAll = document.getElementById('summaryAll');
  const saveBtn = document.getElementById('saveBtn');
  const peacePeriodInfo = document.getElementById('peacePeriodInfo');

  function updatePeacePeriodInfo() {
    if (state.turn < 2) {
      peacePeriodInfo.textContent = `⚔️ Мирная фаза: осталось ${2 - state.turn} месяц(а) до начала войн`;
    } else {
      peacePeriodInfo.textContent = `⚔️ Мирная фаза окончена - можно атаковать`;
    }
  }

  function addLog(text){
    const time = 'Месяц ' + state.turn;
    const line = document.createElement('div');
    line.textContent = `[${time}] ${text}`;
    logEl.prepend(line);
  }

  function renderPlayer(){
    const p = state.countries[0];
    playerName.textContent = p.name;
    const m = monthlyDelta(p);
    const civilians = Math.max(0, p.population - p.army);
    playerStats.innerHTML = `
      <div class="stat"><div><div class="small">Баланс</div><div class="big">$ ${fmt(p.balance)}</div></div><div class="small">Население: ${fmt(p.population)} (мирных: ${fmt(civilians)})</div></div>
      <div class="stat"><div class="small">Заводы</div><div class="big">${p.factories}</div></div>
      <div class="stat"><div class="small">Армия</div><div class="big">${fmt(p.army)} чел</div></div>
      <div class="stat"><div class="small">Налог</div><div class="small">$ ${fmt(m.taxes)} / мес</div></div>
      <div class="stat"><div class="small">Доход от заводов</div><div class="small">$ ${fmt(m.factoryIncome)} / мес</div></div>
      <div class="stat"><div class="small">Содержание армии</div><div class="small">$ ${fmt(m.armyCost)} / мес</div></div>
      <div class="stat"><div class="small">Чистый поток</div><div class="small">$ ${fmt(m.net)} / мес</div></div>
    `;
  }

  function renderCountriesList(){
    countriesList.innerHTML = '';
    for (let i=1;i<state.countries.length;i++){
      const c = state.countries[i];
      if (c.population <= 0) continue; // Не показываем уничтоженные страны
      
      const civilians = Math.max(0, c.population - c.army);
      const div = document.createElement('div');
      div.className = 'country-item';
      div.innerHTML = `<div style="display:flex;flex-direction:column">
          <div style="font-weight:600">${c.name}</div>
          <div class="small" style="margin-top:4px">Население: ${fmt(c.population)} · Заводов: ${c.factories} · Армия: ${fmt(c.army)}</div>
          <div class="small" style="color:${c.martialLaw > 0 ? '#ff6b6b' : '#9aa4b2'}">
            ${c.martialLaw > 0 ? `⚔️ Военное положение (${c.martialLaw} мес.)` : '✓ Мирное время'}
          </div>
        </div>
        <div style="display:flex;flex-direction:column;align-items:flex-end">
          <button data-id="${c.id}" class="btn-small" style="padding:6px;border-radius:8px">Смотреть</button>
        </div>`;
      countriesList.appendChild(div);
      div.querySelector('button').addEventListener('click', ()=> {
        const m = monthlyDelta(c);
        alert(`${c.name}
Население: ${fmt(c.population)}
Мирных: ${fmt(civilians)}
Заводы: ${c.factories}
Армия: ${fmt(c.army)}
Баланс: $ ${fmt(c.balance)}
Агрессивность: ${(c.aggressiveness*100).toFixed(1)}%
Военное положение: ${c.martialLaw > 0 ? 'Да ('+c.martialLaw+' мес.)' : 'Нет'}
Доход/мес: $ ${fmt(m.net)}`);
      });
    }
  }

  function renderAllStats(){
    turnNumber.textContent = state.turn;
    updatePeacePeriodInfo();
    
    const total = state.countries.reduce((acc,c)=>{
      if (c.population > 0) {
        acc.factories += c.factories;
        acc.population += c.population;
        acc.army += c.army;
        acc.balance += c.balance;
        acc.count++;
      }
      return acc;
    }, {factories:0,population:0,army:0,balance:0,count:0});
    summaryAll.textContent = `Активных стран: ${total.count}, Баланс: $ ${fmt(total.balance)}`;
    allStats.innerHTML = `
      <div class="panel" style="flex:1;min-width:140px;">
        <div class="small">Стран всего</div>
        <div class="big"> ${total.count} </div>
      </div>
      <div class="panel" style="flex:1;min-width:140px;">
        <div class="small">Все заводы</div>
        <div class="big"> ${fmt(total.factories)} </div>
      </div>
      <div class="panel" style="flex:1;min-width:140px;">
        <div class="small">Общее население</div>
        <div class="big"> ${fmt(total.population)} </div>
      </div>
      <div class="panel" style="flex:1;min-width:140px;">
        <div class="small">Общая армия</div>
        <div class="big"> ${fmt(total.army)} </div>
      </div>
    `;
  }

  function renderAll(){ 
    renderPlayer(); 
    renderCountriesList(); 
    renderAllStats(); 
    saveState(); 
  }

  // Построить завод
  function buildFactory(player){
    if (player.balance < FACTORY_COST) { 
      addLog('Недостаточно денег для постройки завода.'); 
      return false; 
    }
    player.balance -= FACTORY_COST;
    player.factories += 1;
    addLog(`${player.name} построила завод — баланс: $ ${fmt(player.balance)}.` );
    renderAll();
    return true;
  }

  // Мобилизация модал с проверкой дохода
  function openMobilizeModal(){
    const player = state.countries[0];
    const civilians = Math.max(0, player.population - player.army);
    if (civilians <= 0) { 
      addLog('Нет доступных мирных людей для мобилизации.'); 
      return; 
    }
    
    // Проверяем, сколько можно мобилизовать с сохранением положительного дохода
    const m = monthlyDelta(player);
    let maxByIncome = 0;
    if (m.net > 0) {
      maxByIncome = Math.floor((m.net - 1) / ARMY_COST_PER);
    }
    
    const maxAffordable = Math.floor(player.balance / MOBILIZE_COST);
    const maxAllowed = Math.min(civilians, maxAffordable, maxByIncome);
    
    if (maxAllowed <= 0){ 
      if (maxByIncome <= 0) {
        addLog('Нельзя мобилизовать: доход станет отрицательным.');
      } else {
        addLog('Недостаточно денег для мобилизации.'); 
      }
      return; 
    }

    const backdrop = document.createElement('div'); 
    backdrop.className='modal-backdrop';
    const modal = document.createElement('div'); 
    modal.className='modal';
    modal.innerHTML = `
      <h3>Мобилизация</h3>
      <div class="small">Мирных людей: ${fmt(civilians)} · Баланс: $ ${fmt(player.balance)}</div>
      <div class="small">Текущий доход/мес: $ ${fmt(m.net)}</div>
      <div style="margin-top:8px">
        <label class="small">Количество мобилизуемых (макс ${fmt(maxAllowed)})</label>
        <input id="mobRange" type="range" min="1" max="${maxAllowed}" value="${Math.min( Math.max(1, Math.round(maxAllowed*0.2)), maxAllowed)}" />
        <div style="margin-top:8px" class="small">Стоимость: $ <span id="mobCost"></span></div>
        <div class="small">Будущий доход/мес: $ <span id="futureIncome"></span></div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
        <button id="mobCancel">Отмена</button>
        <button id="mobConfirm" class="btn-strong">Мобилизовать</button>
      </div>
    `;
    backdrop.appendChild(modal);
    document.body.appendChild(backdrop);

    const mobRange = modal.querySelector('#mobRange');
    const mobCost = modal.querySelector('#mobCost');
    const futureIncome = modal.querySelector('#futureIncome');

    function update(){
      const n = parseInt(mobRange.value);
      const cost = n * MOBILIZE_COST;
      mobCost.textContent = fmt(cost);
      
      // Рассчитываем будущий доход
      const futureArmyCost = (player.army + n) * ARMY_COST_PER;
      const futureNet = m.taxes + m.factoryIncome - futureArmyCost;
      futureIncome.textContent = fmt(futureNet);
      futureIncome.style.color = futureNet > 0 ? '#5ad3a1' : '#ff6b6b';
    }
    update();
    mobRange.addEventListener('input', update);

    modal.querySelector('#mobCancel').addEventListener('click', ()=> { 
      backdrop.remove(); 
      addLog('Мобилизация отменена.'); 
    });
    
    modal.querySelector('#mobConfirm').addEventListener('click', ()=> {
      const num = Math.min(parseInt(mobRange.value), maxAllowed);
      const cost = num * MOBILIZE_COST;
      
      // Проверка будущего дохода
      const futureArmyCost = (player.army + num) * ARMY_COST_PER;
      const m = monthlyDelta(player);
      const futureNet = m.taxes + m.factoryIncome - futureArmyCost;
      
      if (futureNet <= 0) {
        alert('Нельзя мобилизовать: доход станет отрицательным!');
        return;
      }
      
      player.balance -= cost;
      player.army += num;
      addLog(`${player.name} мобилизовала ${fmt(num)} чел (стоимость $ ${fmt(cost)}).`);
      backdrop.remove();
      renderAll();
    });
  }

  // Открыть модал атаки
  function openAttackModal(){
    const player = state.countries[0];
    
    // Проверка мирной фазы
    if (state.turn < 2) {
      alert('Атаки запрещены в первые 2 месяца игры!');
      addLog('Атака отменена: первые 2 месяца игры - мирная фаза.');
      return;
    }
    
    if (player.army <= 0){ 
      addLog('Армия пуста — атаковать некому.'); 
      return; 
    }

    // Фильтруем только живые страны
    const validTargets = state.countries.filter(c => 
      c !== player && c.population > 0 && c.army > 0
    );
    
    if (validTargets.length === 0) {
      addLog('Нет подходящих целей для атаки.');
      return;
    }

    const backdrop = document.createElement('div'); 
    backdrop.className='modal-backdrop';
    const modal = document.createElement('div'); 
    modal.className='modal';
    modal.innerHTML = `
      <h3>Атака — выбери цель и количество войск</h3>
      <div class="small">Твоя армия: <strong id="modalPlayerArmy">${fmt(player.army)}</strong> чел</div>
      <div style="margin-top:8px">
        <label class="small">Цель</label>
        <select id="targetSelect" style="width:100%;padding:8px;border-radius:8px;margin-top:6px;background:#051217;color:inherit;border:1px solid rgba(255,255,255,0.03)"></select>
      </div>
      <div style="display:flex;gap:12px;margin-top:10px;align-items:center;">
        <div style="flex:1">
          <label class="small">Выбранные войска: <span id="selCount"></span></label>
          <input id="troopRange" type="range" min="1" max="${player.army}" value="${Math.min( Math.max(1, Math.round(player.army*0.5)), player.army)}" />
          <div style="margin-top:8px"><label><input id="econCheck" type="checkbox"> Экономическая атака</label></div>
        </div>
        <div style="width:120px;text-align:center">
          <div class="pie" id="pieDiv"><div style="text-align:center"><div id="pieLabel" style="font-weight:700"></div></div></div>
        </div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
        <button id="modalCancel">Отмена</button>
        <button id="modalAttack" class="btn-strong">Атаковать</button>
      </div>
      <div style="margin-top:10px" class="small">Инфографика показывает соотношение: выбранные войска vs армия цели.</div>
    `;
    backdrop.appendChild(modal);
    document.body.appendChild(backdrop);

    const targetSelect = modal.querySelector('#targetSelect');
    const troopRange = modal.querySelector('#troopRange');
    const selCount = modal.querySelector('#selCount');
    const pieDiv = modal.querySelector('#pieDiv');
    const pieLabel = modal.querySelector('#pieLabel');
    const econCheck = modal.querySelector('#econCheck');

    // populate targets
    validTargets.forEach(c=> {
      const opt = document.createElement('option');
      opt.value = c.id;
      opt.text = `${c.id}: ${c.name} — армия ${fmt(c.army)} чел, заводов: ${c.factories}`;
      targetSelect.appendChild(opt);
    });

    function updateUI(){
      const targetId = parseInt(targetSelect.value);
      const target = state.countries.find(c=>c.id===targetId);
      const sel = parseInt(troopRange.value);
      selCount.textContent = `${fmt(sel)} чел`;
      const defArmy = target ? target.army : 0;
      const total = sel + defArmy;
      const deg = total === 0 ? 180 : Math.round((sel/total)*360);
      pieDiv.style.background = `conic-gradient(var(--accent) 0deg ${deg}deg, rgba(255,255,255,0.04) ${deg}deg 360deg)`;
      pieLabel.textContent = `${Math.round((sel/Math.max(1,total))*100)}%`;
    }

    targetSelect.addEventListener('change', ()=> updateUI());
    troopRange.addEventListener('input', ()=> updateUI());
    updateUI();

    modal.querySelector('#modalCancel').addEventListener('click', ()=> {
      backdrop.remove();
      addLog('Атака отменена.');
    });

    modal.querySelector('#modalAttack').addEventListener('click', ()=> {
      const tid = parseInt(targetSelect.value);
      const target = state.countries.find(c=>c.id===tid);
      const selected = Math.min(parseInt(troopRange.value), player.army);
      const isEconomic = econCheck.checked;

      // Проверка: не атаковал ли игрок эту цель уже в этом ходу
      const already = state.attacksThisTurn && state.attacksThisTurn[player.id] && state.attacksThisTurn[player.id].includes(tid);
      if (already) {
        alert('Нельзя атаковать одну и ту же страну дважды в одном ходу!');
        addLog('Попытка повторной атаки на ту же страну — отклонено.');
        return;
      }

      backdrop.remove();
      simulateAttack(player, target, selected, isEconomic);
    });
  }

  // Функция показа анимации битвы
  function showBattleAnimation(attacker, defender, selectedTroops, isEconomic, battleData) {
    return new Promise((resolve) => {
      const backdrop = document.createElement('div');
      backdrop.className = 'modal-backdrop';
      
      const modal = document.createElement('div');
      modal.className = 'modal battle-modal';
      
      const attackerInitialArmy = selectedTroops;
      const defenderInitialArmy = defender.army;
      
      const attackerRemaining = battleData.attackerRemaining;
      const defenderRemaining = battleData.defenderRemaining;
      
      const attackerLossPercent = attackerInitialArmy === 0 ? 0 : ((attackerInitialArmy - attackerRemaining) / attackerInitialArmy) * 100;
      const defenderLossPercent = defenderInitialArmy === 0 ? 0 : ((defenderInitialArmy - defenderRemaining) / defenderInitialArmy) * 100;
      
      modal.innerHTML = `
        <h3>⚔️ Битва: ${attacker.name} против ${defender.name}</h3>
        <div class="small">${isEconomic ? 'Экономическая война' : 'Политическая война'}</div>
        
        <div class="battle-container">
          <div class="army-column">
            <div class="army-bar-container">
              <div class="army-bar" id="attackerBar" style="height:100%"></div>
            </div>
            <div class="army-info">
              <div class="army-name">${attacker.name}</div>
              <div class="army-count" id="attackerCount">${fmt(attackerInitialArmy)} военных</div>
            </div>
          </div>
          
          <div class="army-column">
            <div class="army-bar-container">
              <div class="army-bar defender" id="defenderBar" style="height:100%"></div>
            </div>
            <div class="army-info">
              <div class="army-name">${defender.name}</div>
              <div class="army-count" id="defenderCount">${fmt(defenderInitialArmy)} военных</div>
            </div>
          </div>
        </div>
        
        <div class="battle-timeline">
          <div class="battle-progress" id="battleProgress"></div>
        </div>
        
        <div style="display:flex;justify-content:space-between;margin:10px 0;">
          <div class="small">Начало битвы</div>
          <div class="small" id="timeRemaining">Анимация: 5с</div>
          <div class="small">Конец битвы</div>
        </div>
        
        <div id="battleResults" class="battle-results">
          <h4>Результаты битвы:</h4>
          <div class="small">Атакующий (${attacker.name}):</div>
          <div>- Потери: ${fmt(battleData.lossesAtk)} военных</div>
          <div>- Осталось: ${fmt(attackerRemaining)} военных</div>
          <br>
          <div class="small">Защитник (${defender.name}):</div>
          <div>- Потери: ${fmt(battleData.lossesDef)} военных</div>
          <div>- Осталось: ${fmt(defenderRemaining)} военных</div>
          ${battleData.captured ? `<br><div style="color:#5ad3a1"><strong>${attacker.name} захватила ${defender.name}!</strong></div>` : ''}
          ${battleData.lostFactories > 0 ? `<div>- Потеряно заводов: ${battleData.lostFactories}</div>` : ''}
          ${battleData.lostCivilians > 0 ? `<div>- Погибло мирных: ${fmt(battleData.lostCivilians)}</div>` : ''}
        </div>
        
        <div style="display:flex;gap:8px;justify-content:center;margin-top:12px;">
          <button id="skipAnimation" class="btn-strong">Пропустить анимацию</button>
          <button id="closeBattle" style="display:none;">Закрыть</button>
        </div>
      `;
      
      backdrop.appendChild(modal);
      document.body.appendChild(backdrop);
      
      const attackerBar = modal.querySelector('#attackerBar');
      const defenderBar = modal.querySelector('#defenderBar');
      const attackerCount = modal.querySelector('#attackerCount');
      const defenderCount = modal.querySelector('#defenderCount');
      const battleProgress = modal.querySelector('#battleProgress');
      const timeRemaining = modal.querySelector('#timeRemaining');
      const battleResults = modal.querySelector('#battleResults');
      const skipButton = modal.querySelector('#skipAnimation');
      const closeButton = modal.querySelector('#closeBattle');
      
      let animationDuration = 5000; // 5 секунд
      let startTime = Date.now();
      let animationRunning = true;
      let animationFrame;
      
      function updateAnimation() {
        if (!animationRunning) return;
        
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / animationDuration, 1);
        
        // Обновляем полоску прогресса
        battleProgress.style.width = (progress * 100) + '%';
        
        // Обновляем время
        const remaining = Math.ceil((animationDuration - elapsed) / 1000);
        timeRemaining.textContent = `Анимация: ${remaining}с`;
        
        // Анимируем столбцы армий
        const attackerHeight = 100 - (progress * attackerLossPercent);
        const defenderHeight = 100 - (progress * defenderLossPercent);
        
        attackerBar.style.height = Math.max(0, attackerHeight) + '%';
        defenderBar.style.height = Math.max(0, defenderHeight) + '%';
        
        // Обновляем цифры потерь
        const currentAttackerLoss = Math.round(progress * battleData.lossesAtk);
        const currentDefenderLoss = Math.round(progress * battleData.lossesDef);
        
        attackerCount.textContent = `${fmt(attackerInitialArmy - currentAttackerLoss)} военных`;
        defenderCount.textContent = `${fmt(defenderInitialArmy - currentDefenderLoss)} военных`;
        
        if (progress < 1) {
          animationFrame = requestAnimationFrame(updateAnimation);
        } else {
          finishAnimation();
        }
      }
      
      function finishAnimation() {
        animationRunning = false;
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
        }
        
        // Устанавливаем финальные значения
        attackerBar.style.height = Math.max(0, 100 - attackerLossPercent) + '%';
        defenderBar.style.height = Math.max(0, 100 - defenderLossPercent) + '%';
        
        attackerCount.textContent = `${fmt(attackerRemaining)} военных`;
        defenderCount.textContent = `${fmt(defenderRemaining)} военных`;
        
        // Показываем результаты
        battleResults.style.display = 'block';
        skipButton.style.display = 'none';
        closeButton.style.display = 'inline-block';
        timeRemaining.textContent = 'Битва завершена';
      }
      
      function skipAnimation() {
        finishAnimation();
      }
      
      // Запускаем анимацию
      animationFrame = requestAnimationFrame(updateAnimation);
      
      // Обработчики событий
      skipButton.addEventListener('click', skipAnimation);
      closeButton.addEventListener('click', () => {
        backdrop.remove();
        resolve();
      });
      
      // Автоматическое завершение через 5 секунд
      setTimeout(() => {
        if (animationRunning) {
          finishAnimation();
        }
      }, animationDuration + 500);
    });
  }

  // Симуляция атаки с анимацией
  async function simulateAttack(attackerCountry, defenderCountry, selectedTroops, isEconomic=false){
    if (!defenderCountry) { addLog('Цель не выбрана.'); return; }
    if (selectedTroops <= 0){ addLog('Выбрано 0 войск.'); return; }
    if (attackerCountry.army <= 0){ addLog('У тебя нет армии.'); return; }
    selectedTroops = Math.min(selectedTroops, attackerCountry.army);

    if (defenderCountry.army <= 0){ 
      addLog('Цель не имеет армии — нападение бессмысленно.'); 
      return; 
    }

    // Запрет для игрока атаковать одну ту же цель дважды за ход (защита от повторных атак)
    if (attackerCountry.isPlayer) {
      state.attacksThisTurn = state.attacksThisTurn || {};
      const arr = state.attacksThisTurn[attackerCountry.id] || [];
      if (arr.includes(defenderCountry.id)) {
        addLog('Нельзя атаковать одну и ту же страну дважды в одном ходу.');
        return;
      }
    }

    // порог: 1% населения защитника => количество потерь для счёта одного порога
    const thresholdCount = Math.max(1, Math.round(defenderCountry.population * 0.01));
    let defenderLossCounter = 0;

    let atk = selectedTroops;
    let def = defenderCountry.army;
    
    const minE = Math.min(atk, def);
    const maxE = Math.max(atk, def);
    const events = randInt(minE, maxE);

    const initialAtk = atk;
    const initialDef = def;

    // Собираем данные для анимации
    const battleData = {
      attackerInitialArmy: selectedTroops,
      defenderInitialArmy: defenderCountry.army,
      lossesAtk: 0,
      lossesDef: 0,
      attackerRemaining: atk,
      defenderRemaining: def,
      captured: false,
      lostFactories: 0,
      lostCivilians: 0
    };

    for (let i=0;i<events;i++){
      if (atk <= 0 || def <= 0) break;
      const probDefLose = atk / (atk + def);
      if (Math.random() < probDefLose){
        def -= 1;
        defenderLossCounter += 1;
        // если накопились потери, применяем эффект
        if (defenderLossCounter >= thresholdCount){
          const times = Math.floor(defenderLossCounter / thresholdCount);
          for (let t=0; t<times; t++){
            if (isEconomic){
              const lostFactories = randInt(2,5);
              const actualLostFactories = Math.min(defenderCountry.factories, lostFactories);
              battleData.lostFactories += actualLostFactories;

              const currentCiv = Math.max(0, defenderCountry.population - defenderCountry.army);
              const perc = randFloat(0.0075, 0.0175);
              const dead = Math.min(currentCiv, Math.round(defenderCountry.population * perc));
              battleData.lostCivilians += dead;
            } else {
              battleData.lostFactories += 1;
            }
          }
          defenderLossCounter = defenderLossCounter % thresholdCount;
        }
      } else {
        atk -= 1;
      }
    }

    battleData.lossesAtk = initialAtk - atk;
    battleData.lossesDef = initialDef - def;
    battleData.attackerRemaining = atk;
    battleData.defenderRemaining = def;

    // Показываем анимацию битвы если участвует игрок
    if (attackerCountry.isPlayer || defenderCountry.isPlayer) {
      await showBattleAnimation(attackerCountry, defenderCountry, selectedTroops, isEconomic, battleData);
    }

    // Применяем результаты битвы: убираем потери из армий
    attackerCountry.army = Math.max(0, attackerCountry.army - battleData.lossesAtk);
    defenderCountry.army = Math.max(0, defenderCountry.army - battleData.lossesDef);

    // ВАЖНО: потери военнослужащих удаляются из населения безвозвратно
    attackerCountry.population = Math.max(0, attackerCountry.population - battleData.lossesAtk);
    defenderCountry.population = Math.max(0, defenderCountry.population - battleData.lossesDef);

    // Если после уменьшения населения армия больше населения — корректируем армию
    if (attackerCountry.army > attackerCountry.population) attackerCountry.army = attackerCountry.population;
    if (defenderCountry.army > defenderCountry.population) defenderCountry.army = defenderCountry.population;

    // Применяем потери заводов и мирных (в случае экономической атаки)
    if (battleData.lostFactories > 0) {
      defenderCountry.factories = Math.max(0, defenderCountry.factories - battleData.lostFactories);
      if (isEconomic) {
        defenderCountry.population = Math.max(0, defenderCountry.population - battleData.lostCivilians);
        if (defenderCountry.army > defenderCountry.population){
          defenderCountry.army = Math.max(0, defenderCountry.population);
        }
      }
    }

    // Логи о потерях людей (военные уже списаны из населения выше)
    if (battleData.lossesAtk > 0) {
      addLog(`${attackerCountry.name} потеряла ${fmt(battleData.lossesAtk)} военных (убиты).`);
    }
    if (battleData.lossesDef > 0) {
      addLog(`${defenderCountry.name} потеряла ${fmt(battleData.lossesDef)} военных (убиты).`);
    }

    addLog(`${attackerCountry.name} атаковала ${defenderCountry.name} (${isEconomic? 'экономическая':''}). Использовано ${fmt(selectedTroops)} войск, события: ${events}. Потери — атакующие: ${fmt(battleData.lossesAtk)}, защищающиеся: ${fmt(battleData.lossesDef)}.`);

    if (battleData.lostFactories > 0) {
      if (isEconomic){
        addLog(`${defenderCountry.name} потеряла ${battleData.lostFactories} завод(а/ов) (экономическая война) и ${fmt(battleData.lostCivilians)} мирных при пороге потерь.`);
      } else {
        addLog(`${defenderCountry.name} потеряла ${battleData.lostFactories} завод(а/ов) в результате боевых потерь.`);
      }
    }

    // проверяем результат: если защита обнулилась — захват
    if (def <= 0 && atk > 0){
      battleData.captured = true;
      const transferredPopulation = defenderCountry.population;
      const transferredFactories = defenderCountry.factories;
      const transferredBalance = defenderCountry.balance;

      attackerCountry.population += transferredPopulation;
      attackerCountry.factories += transferredFactories;
      attackerCountry.balance += transferredBalance;

      // очищаем побеждённую страну
      defenderCountry.population = 0;
      defenderCountry.factories = 0;
      defenderCountry.army = 0;
      defenderCountry.balance = 0;
      if (!defenderCountry.isPlayer) {
        defenderCountry.martialLaw = 0;
        defenderCountry.militaryFund = 0;
        defenderCountry.factoryFund = 0;
      }

      addLog(`Победа! ${attackerCountry.name} захватила ${defenderCountry.name} — получено ${fmt(transferredPopulation)} людей, ${fmt(transferredFactories)} заводов и $ ${fmt(transferredBalance)} баланса.`);

      // --- НОВОЕ: планируем акции возмездия от других ботов в следующем месяце ---
      // Для каждого другого бота (живого, кроме захваченного и атакующего) даём шанс 10% атаковать атакующего экономической атакой в следующем месяце
      const scheduled = [];
      for (let bot of state.countries) {
        if (!bot || bot === attackerCountry) continue;
        if (bot.id === defenderCountry.id) continue; // захваченная страна уже очищена
        if (bot.population <= 0) continue;
        if (bot.isPlayer) continue; // игрокы не участвуют в автоматических возмездиях
        if (Math.random() < 0.10) {
          scheduled.push({ sourceId: bot.id, targetId: attackerCountry.id });
        }
      }
      if (!state.pendingRetaliations) state.pendingRetaliations = [];
      if (scheduled.length > 0) {
        state.pendingRetaliations.push(...scheduled);
        addLog(`Запланировано возмездие: ${scheduled.length} бот(а/ов) могут атаковать ${attackerCountry.name} в следующем месяце.`);
      }
    } else if (atk <= 0 && def > 0){
      addLog(`${attackerCountry.name} потерпела поражение — захват не состоялся. Потери нанесены.`);
    } else {
      addLog(`Бой окончен: обе стороны всё ещё имеют войска. (атк: ${fmt(attackerCountry.army)}, деф: ${fmt(defenderCountry.army)})`);
    }

    // Если защитник выжил и это бот - включаем военное положение
    if (!defenderCountry.isPlayer && defenderCountry.army > 0 && !battleData.captured) {
      defenderCountry.martialLaw = 5;
      addLog(`${defenderCountry.name} вводит военное положение на 5 месяцев!`);
    }

    // отмечаем факт, что атакующий (если игрок) атаковал эту цель в этом ходу, чтобы не дать повторной атаки
    if (attackerCountry.isPlayer) {
      state.attacksThisTurn = state.attacksThisTurn || {};
      state.attacksThisTurn[attackerCountry.id] = state.attacksThisTurn[attackerCountry.id] || [];
      if (!state.attacksThisTurn[attackerCountry.id].includes(defenderCountry.id)) {
        state.attacksThisTurn[attackerCountry.id].push(defenderCountry.id);
      }
    }

    renderAll();
  }

  // следующий месяц + логика ботов (теперь async чтобы ждать возмездий)
  async function nextMonth(){
    state.turn += 1;

    // Сбрасываем список атак игрока за предыдущий ход (новый ход — новые атаки)
    state.attacksThisTurn = {};

    // Обрабатываем игрока
    const player = state.countries[0];
    const playerDelta = monthlyDelta(player);
    player.balance += playerDelta.net;
    
    // Проверяем демобилизацию игрока если доход отрицательный
    if (playerDelta.net < 0) {
      autoDemobilize(player);
    }
    
    // Обрабатываем ботов
    for (let i = 1; i < state.countries.length; i++) {
      const bot = state.countries[i];
      if (bot.population <= 0) continue;
      
      // Применяем месячный доход
      const botDelta = monthlyDelta(bot);
      bot.balance += botDelta.net;
      
      // Логика бота
      botLogic(bot);
    }
    
    addLog('Прошёл месяц. Все страны получили доход/расход.');

    // --- Обработка запланированных возмездий (в этом месяце) ---
    if (state.pendingRetaliations && state.pendingRetaliations.length > 0) {
      const toProcess = state.pendingRetaliations.slice();
      state.pendingRetaliations = []; // очистим — это однократная акция в следующем месяце
      for (let item of toProcess) {
        const src = state.countries.find(c => c.id === item.sourceId);
        const tgt = state.countries.find(c => c.id === item.targetId);
        if (!src || !tgt) continue;
        if (src.population <= 0 || src.army <= 0) continue;
        if (tgt.population <= 0) continue;
        // выбираем разумное число войск для экономической атаки (пример: 30% армии или минимум 1)
        const troops = Math.max(1, Math.round(src.army * 0.3));
        addLog(`${src.name} начинает акцию возмездия против ${tgt.name} — экономическая атака (${fmt(troops)} чел).`);
        // Боты не ждём завершения анимации (по логике ботов), но если цель — игрок, simulateAttack покажет анимацию и ждёт.
        // Чтобы избежать блокировки всех остальных, ждём simulateAttack если вовлечён игрок (чтобы анимация корректно отобразилась).
        const promise = simulateAttack(src, tgt, Math.min(troops, src.army), true);
        // если вовлечён игрок — ждём, иначе не ждём
        if (src.isPlayer || tgt.isPlayer) {
          await promise;
        }
      }
    }

    renderAll();
  }

  // Сброс
  function resetGame(){
    if (!confirm('Сбросить игру и начать заново?')) return;
    localStorage.removeItem('countries_game_v5');
    state = { turn: 0, countries: [], pendingRetaliations: [], attacksThisTurn: {} };
    for (let i=1;i<=10;i++) state.countries.push(makeCountry(i, i===1));
    saveState();
    renderAll();
    addLog('Игра сброшена.');
  }

  // Инициализация
  initIfEmpty();
  renderAll();

  // события
  btnNext.addEventListener('click', ()=> { nextMonth(); });
  btnReset.addEventListener('click', resetGame);
  saveBtn.addEventListener('click', ()=> { saveState(); addLog('Сохранено вручную.'); });
  buildFactoryBtn.addEventListener('click', ()=> buildFactory(state.countries[0]));
  attackBtn.addEventListener('click', ()=> openAttackModal());
  mobilizeBtn.addEventListener('click', ()=> openMobilizeModal());

  // hint
  if (!localStorage.getItem('countries_game_v5_hint')) {
    addLog('Добро пожаловать! ');
    addLog('При атаке появится визуальная анимация битвы.');
    localStorage.setItem('countries_game_v5_hint', '1');
  }

  // shortcut
  window.addEventListener('keydown', (e)=> { 
    if (e.code === 'Space' && !e.target.matches('input, textarea, select')){ 
      e.preventDefault(); 
      nextMonth(); 
    } 
  });

})();
</script>
</body>
</html>
